import asyncio
import os
import logging
import re
import json
from typing import List
from pathlib import Path
from playwright.async_api import async_playwright, Download
from undetected_playwright import stealth_async

# ======================================================
# GENERAL SETTINGS
# ======================================================
GROK_URL = "https://grok.com/imagine"
BASE_DIR = Path(__file__).resolve().parent
DOWNLOAD_ROOT = BASE_DIR / "videos"
VIDEO_SCRIPTS_FOLDER = BASE_DIR / "video_scripts"
LOG_FILE = "automation.log"
CHECK_INTERVAL = 3000
MAX_WAIT = 420000
AFTER_DOWNLOAD_WAIT = 9000
BETWEEN_SCENES_WAIT = 7000
BETWEEN_VIDEOS_WAIT = 18000
MAX_RETRIES = 3
HEADLESS = False
WINDOW_WIDTH = 1366
WINDOW_HEIGHT = 768

USER_DATA_DIR = "./user_data"
SLOW_MO = 20
INTERACTION_RETRIES = 3

LAUNCH_ARGS = [
    "--no-sandbox",
    "--disable-setuid-sandbox",
    "--disable-blink-features=AutomationControlled",
    "--start-maximized",
    "--disable-web-security",
    "--disable-features=IsolateOrigins,site-per-process",
    "--disable-infobars",
    "--window-size=1366,768",
    "--disable-extensions",
    "--disable-dev-shm-usage",
    "--disable-gpu",
    "--disable-software-rasterizer",
    "--ignore-certificate-errors",
    "--disable-features=TranslateUI",
    "--metrics-recording-only",
    "--disable-default-apps",
    "--mute-audio"
]

# SELECTORS (ØªÙ… ØªØµØ­ÙŠØ­ aria-label)
GROK_SETTING_RATIO_BUTTON = 'button[data-testid="ratio-vertical"]'
GROK_SETTING_VIDEO_MODE_BUTTON = 'button[data-testid="mode-video"]'
GROK_SETTING_QUALITY_BUTTON = 'button[data-testid="quality-high"]'
GROK_SETTING_WATERMARK_OFF = 'button[data-testid="watermark-off"]'
GROK_SETTING_MUTE_ON = 'button[data-testid="mute-on"]'

# ÙŠÙ…ÙƒÙ†Ùƒ ØªØ¹Ø·ÙŠÙ„ Ø£ÙŠ Ø¥Ø¹Ø¯Ø§Ø¯ Ø¨Ø¬Ø¹Ù„Ù‡ False
ENABLE_GROK_SETTING_RATIO = True
ENABLE_GROK_SETTING_VIDEO_MODE = True
ENABLE_GROK_SETTING_QUALITY = True
ENABLE_GROK_SETTING_WATERMARK_OFF = True
ENABLE_GROK_SETTING_MUTE_ON = True

PAGE_READY_SELECTOR = 'p[data-placeholder="Tapez pour imaginer"]'
INPUT_SELECTOR = 'p[data-placeholder="Tapez pour imaginer"]'
CANCEL_BUTTON_SELECTOR = 'button:has-text("Annuler la vidÃ©o")'
DOWNLOAD_BUTTON_SELECTOR = 'button[aria-label="TÃ©lÃ©charger"]'  # ØªÙ… Ø§Ù„ØªØµØ­ÙŠØ­

SCENE_FILENAME_PATTERN = "scene_%INDEX%.mp4"
SANITIZE_FILENAMES = True
DEBUG_MODE = True
SAVE_HTML_ON_ERROR = True
SCREENSHOT_ON_ERROR = True

logging.basicConfig(
    filename=LOG_FILE,
    level=logging.DEBUG if DEBUG_MODE else logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
console = logging.StreamHandler()
console.setLevel(logging.INFO)
logging.getLogger().addHandler(console)


def sanitize_filename(name: str) -> str:
    if not SANITIZE_FILENAMES:
        return name
    return re.sub(r'[<>:"/\\|?*]', '_', name.strip())


async def smart_wait_for(page, selector: str, *, timeout: int = MAX_WAIT, state: str = "visible", label: str = ""):
    last_error = None
    for attempt in range(1, INTERACTION_RETRIES + 1):
        try:
            return await page.wait_for_selector(selector, timeout=timeout, state=state)
        except Exception as error:
            last_error = error
            print(f"âš ï¸ Ø§Ù†ØªØ¸Ø§Ø± ÙØ´Ù„ ({label or selector}) - Ù…Ø­Ø§ÙˆÙ„Ø© {attempt}/{INTERACTION_RETRIES}")
            await asyncio.sleep(1.2 * attempt)
    raise RuntimeError(f"ÙØ´Ù„ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± Ù„Ù„Ø¹Ù†ØµØ±: {label or selector}. Ø§Ù„Ø³Ø¨Ø¨: {last_error}") from last_error


async def smart_click(page, selector: str, *, timeout: int = 30000, label: str = ""):
    last_error = None
    locator = page.locator(selector).first

    for attempt in range(1, INTERACTION_RETRIES + 1):
        try:
            await smart_wait_for(page, selector, timeout=timeout, label=label)
            await locator.scroll_into_view_if_needed(timeout=timeout)
            await locator.hover(timeout=timeout)
            await locator.click(timeout=timeout)
            return
        except Exception as error:
            last_error = error
            print(f"âš ï¸ Ù†Ù‚Ø± Ø¹Ø§Ø¯ÙŠ ÙØ´Ù„ ({label or selector}) - Ù…Ø­Ø§ÙˆÙ„Ø© {attempt}/{INTERACTION_RETRIES}")
            try:
                await locator.click(timeout=timeout, force=True)
                return
            except Exception:
                await asyncio.sleep(0.8 * attempt)

    raise RuntimeError(f"ÙØ´Ù„ Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø§Ù„Ø¹Ù†ØµØ±: {label or selector}. Ø§Ù„Ø³Ø¨Ø¨: {last_error}") from last_error


async def smart_fill(page, selector: str, text: str, *, timeout: int = 30000, label: str = ""):
    last_error = None
    locator = page.locator(selector).first

    for attempt in range(1, INTERACTION_RETRIES + 1):
        try:
            await smart_wait_for(page, selector, timeout=timeout, label=label)
            await locator.scroll_into_view_if_needed(timeout=timeout)
            await locator.click(timeout=timeout)
            await page.keyboard.press("Control+A")
            await page.keyboard.press("Backspace")
            await page.keyboard.type(text, delay=50)
            return
        except Exception as error:
            last_error = error
            print(f"âš ï¸ Ù…Ù„Ø¡ ÙØ´Ù„ ({label or selector}) - Ù…Ø­Ø§ÙˆÙ„Ø© {attempt}/{INTERACTION_RETRIES}")
            try:
                await locator.fill(text, timeout=timeout)
                return
            except Exception:
                await asyncio.sleep(0.8 * attempt)

    raise RuntimeError(f"ÙØ´Ù„ Ø§Ù„Ù…Ù„Ø¡ Ù„Ù„Ø¹Ù†ØµØ±: {label or selector}. Ø§Ù„Ø³Ø¨Ø¨: {last_error}") from last_error


async def apply_grok_settings(page):
    print("ğŸ”§ ØªØ·Ø¨ÙŠÙ‚ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Grok (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)...")
    settings = [
        ("ratio", GROK_SETTING_RATIO_BUTTON, ENABLE_GROK_SETTING_RATIO),
        ("video_mode", GROK_SETTING_VIDEO_MODE_BUTTON, ENABLE_GROK_SETTING_VIDEO_MODE),
        ("quality", GROK_SETTING_QUALITY_BUTTON, ENABLE_GROK_SETTING_QUALITY),
        ("watermark_off", GROK_SETTING_WATERMARK_OFF, ENABLE_GROK_SETTING_WATERMARK_OFF),
        ("mute_on", GROK_SETTING_MUTE_ON, ENABLE_GROK_SETTING_MUTE_ON)
    ]

    for setting_name, selector, is_enabled in settings:
        if not is_enabled:
            print(f"â­ï¸ ØªÙ… ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯ Ù…Ù† Ø§Ù„ÙƒÙˆÙ†ÙÙŠØ¬: {setting_name}")
            continue

        try:
            await smart_click(page, selector, timeout=10000, label=f"Grok setting: {selector}")
            print(f"âœ… ØªÙ…: {selector}")
        except Exception:
            print(f"â­ï¸ ØªØ¬Ø§Ù‡Ù„ (Ù…ÙØ¹Ù„ Ø¨Ø§Ù„ÙØ¹Ù„): {selector}")
    await asyncio.sleep(3)


async def generate_scene(page, prompt: str, scene_path: str, index: int, title: str):
    for attempt in range(1, MAX_RETRIES + 1):
        try:
            print(f"ğŸ¥ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ù…Ø´Ù‡Ø¯ {index} - Ù…Ø­Ø§ÙˆÙ„Ø© {attempt}")
            await smart_fill(page, INPUT_SELECTOR, prompt, timeout=30000, label="Ø­Ù‚Ù„ Ø§Ù„Ø¨Ø±ÙˆÙ…Ø¨Øª")
            await page.keyboard.press("Enter")
            await asyncio.sleep(5)

            print("â³ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„ØªÙˆÙ„ÙŠØ¯...")
            await smart_wait_for(page, CANCEL_BUTTON_SELECTOR, timeout=60000, label="Ø²Ø± Ø¥Ù„ØºØ§Ø¡ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ")
            print("â³ Ø§Ù†ØªØ¸Ø§Ø± Ø²Ø± Ø§Ù„ØªØ­Ù…ÙŠÙ„...")
            await smart_wait_for(page, DOWNLOAD_BUTTON_SELECTOR, timeout=MAX_WAIT, label="Ø²Ø± Ø§Ù„ØªØ­Ù…ÙŠÙ„")

            async with page.expect_download(timeout=90000) as download_info:
                await smart_click(page, DOWNLOAD_BUTTON_SELECTOR, timeout=20000, label="ØªÙ†Ø²ÙŠÙ„ Ø§Ù„Ù…Ø´Ù‡Ø¯")
            download: Download = await download_info.value
            await download.save_as(scene_path)

            print(f"âœ… ØªÙ… Ø§Ù„ØªØ­Ù…ÙŠÙ„: {scene_path}")
            await asyncio.sleep(AFTER_DOWNLOAD_WAIT / 1000)
            return True
        except Exception as e:
            print(f"âŒ ÙØ´Ù„ (Ù…Ø­Ø§ÙˆÙ„Ø© {attempt}): {e}")
            if SCREENSHOT_ON_ERROR:
                await page.screenshot(path=f"error_{title}_{index}_{attempt}.png")
            if attempt == MAX_RETRIES:
                raise
            await asyncio.sleep(15)
    return False


async def process_video_script(page, script_path: str):
    title = sanitize_filename(Path(script_path).stem)
    video_dir = DOWNLOAD_ROOT / title
    if video_dir.exists():
        print(f"â­ï¸ ØªØ®Ø·ÙŠ {title}")
        return
    video_dir.mkdir(parents=True, exist_ok=True)

    prompts = read_prompts(script_path)
    if not prompts:
        print("âš ï¸ Ù…Ù„Ù ÙØ§Ø±Øº")
        return
    print(f"ğŸš€ Ø¨Ø¯Ø¡ {title} ({len(prompts)} Ù…Ø´Ù‡Ø¯)")
    for index, prompt in enumerate(prompts, 1):
        scene_path = video_dir / SCENE_FILENAME_PATTERN.replace("%INDEX%", f"{index:04d}")
        await generate_scene(page, prompt, str(scene_path), index, title)
        await asyncio.sleep(BETWEEN_SCENES_WAIT / 1000)
    print(f"ğŸ‰ Ø§ÙƒØªÙ…Ù„ {title}")


def list_script_files() -> List[Path]:
    return sorted(
        file_path
        for file_path in VIDEO_SCRIPTS_FOLDER.iterdir()
        if file_path.is_file() and file_path.suffix.lower() == ".txt"
    )


def read_prompts(script_path: str) -> List[str]:
    candidate_encodings = ("utf-8", "utf-8-sig", "cp1256")
    last_error = None

    for encoding in candidate_encodings:
        try:
            with open(script_path, encoding=encoding) as script_file:
                return [line.strip() for line in script_file if line.strip()]
        except UnicodeDecodeError as error:
            last_error = error

    raise RuntimeError(f"ØªØ¹Ø°Ø± Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…Ù„Ù: {script_path}. Ø§Ù„Ø³Ø¨Ø¨: {last_error}") from last_error


async def main():
    print("ğŸš€ Ø¨Ø¯Ø¡ Ø§Ù„Ø³ÙƒØ±ÙŠØ¨Øª...")
    VIDEO_SCRIPTS_FOLDER.mkdir(parents=True, exist_ok=True)
    DOWNLOAD_ROOT.mkdir(parents=True, exist_ok=True)
    print(f"ğŸ“ Ø§Ù„Ù…Ø¬Ù„Ø¯Ø§Øª Ø¬Ø§Ù‡Ø²Ø©: {VIDEO_SCRIPTS_FOLDER} Ùˆ {DOWNLOAD_ROOT}")

    async with async_playwright() as p:
        context = await p.chromium.launch_persistent_context(
            USER_DATA_DIR,
            headless=HEADLESS,
            slow_mo=SLOW_MO,
            viewport={"width": WINDOW_WIDTH, "height": WINDOW_HEIGHT},
            args=LAUNCH_ARGS
        )
        context.set_default_navigation_timeout(90000)
        context.set_default_timeout(60000)

        page = context.pages[0] if context.pages else await context.new_page()
        await stealth_async(page)
        await page.add_init_script("""() => {
            Object.defineProperty(navigator, 'webdriver', { get: () => false });
            window.chrome = { runtime: {}, app: {}, webstore: {} };
            Object.defineProperty(navigator, 'languages', { get: () => ['fr-FR', 'fr'] });
            Object.defineProperty(navigator, 'plugins', { get: () => [1, 2, 3] });
        }""")

        if os.path.exists("cookies.json"):
            with open("cookies.json", "r", encoding="utf-8") as f:
                cookies = json.load(f)
            await context.add_cookies(cookies)
            print(f"ğŸª ØªÙ… Ø­Ù‚Ù† {len(cookies)} ÙƒÙˆÙƒÙŠ")
        else:
            print("âš ï¸ Ù„Ø§ ÙŠÙˆØ¬Ø¯ cookies.json â€“ Ø§Ù„Ù…Ø±Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ Ø¹Ø§Ø¯ÙŠØ©")

        print("ğŸŒ ÙØªØ­ Grok Imagine...")
        await page.goto(GROK_URL, timeout=90000)
        await page.wait_for_load_state('networkidle', timeout=MAX_WAIT)
        await smart_wait_for(page, PAGE_READY_SELECTOR, timeout=MAX_WAIT, label="Ø¬Ø§Ù‡Ø²ÙŠØ© ØµÙØ­Ø© Grok")
        print("âœ… Ø§Ù„ØµÙØ­Ø© Ø¬Ø§Ù‡Ø²Ø©")

        await apply_grok_settings(page)

        while True:
            script_files = list_script_files()
            if script_files:
                print(f"ğŸ“‚ ÙˆØ¬Ø¯ {len(script_files)} Ù…Ù„Ù Ø¬Ø¯ÙŠØ¯")
                for script_file in script_files:
                    await process_video_script(page, str(script_file))
            else:
                print(f"â³ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù„ÙØ§Øª .txt ÙÙŠ: {VIDEO_SCRIPTS_FOLDER} ... Ø§Ù„ØªØ­Ù‚Ù‚ ÙƒÙ„ 3 Ø«ÙˆØ§Ù†ÙŠ")
            await asyncio.sleep(CHECK_INTERVAL / 1000)


if __name__ == "__main__":
    asyncio.run(main())
